<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">

  <html>

    <head>
      <meta	http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	  <title>Dolphin Demo Technical Documentation</title>
    </head>

    <body>
<!-- abora:header -->
      <h1>Dolphin Demo Technical Documentation</h1>
<!-- abora:header_close -->

		<p><font color="red">---- Document still being written ----</font></p>

		<p>The implementation of the Dolphin Demo was driven out of a lack
		of appreciation of the features of Udanax-Gold, and definitely an
		understanding of how it could all be made to work. I had access to
		the source code released by XOC, but it was incomplete, and it's
		size defied easy interpretation. I found two critical papers on
		the @link:sunless_sea@ website that gave an overview of the Ent
		data structure, and the basic infrastructure for client
		developers.</p>

		<p>Starting from scratch as I did with the Demo forced me to gain
		some understanding of the core constraints and pressures on the
		design, and the learning about the design from the inside. I was
		not intending to implement a feature-by-feature clone of
		Udanax-Gold, but I did want to explore the basic features of a
		xanalogical data server and I did want to improve my knowledge of
		Udanax-Gold. As I progressed through a few iterations of the
		application later discoveries would reveal misunderstandings made
		early in the project. I often just drove straight on rather than
		rework the effected parts. This allowed me to cover more ground,
		but has left some rough edges and unexplored spaces.</p>

		<p>The majority of work on the Demo was accomplished during a two
		month summer holiday break during 2002. This was kindly green lighted by my
		employer, @link:intware@. Many thanks.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Data Structure Requirements</h3>
</td></tr></table>

		<p>The core of the implementation is a limited version of the Ent
		data structure at the heart of Udanax-Gold. As mentioned above
		this isn't a strict subset of the original design, and is more of
		a twisted take on it derived from my shallow interpretation.</p>

		<p>There are a number of features that we want to be present in
		this structure.</p>

		<ul>
			<li>Large documents</li>
			<li>Multiple versions of the same document</li>
			<li>Minimise space overhead of multiple document versions</li>
			<li>Fine grained links</li>
			<li>Minimise time overhead of modifying documents</li>
			<li>Natural programming API</li>
			<li>Links valid across document versions</li>
			<li>Remote caching of document fragments</li>
		</ul>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Base Implementation</h3>
</td></tr></table>

		<p>The contents of a document and the structure defining the
		different versions and links between content are split into two
		layers. The Content layer holds chunks of contiguous sequences of
			document data. These are connected to one or more leaves of a
		series of binary search trees each defining a document.</p>

		<p>The structure of the contents is built from a binary search
		tree whose leaves are the contents of the document. The root of
		the tree corresponds to one version of the document, and walking
		the leaves from left to right will produce the entire document. At
		each interior node a split integer indicates the position of
		the first element that can be reached by its right branch, and all
		elements to the left will be before this position.</p>

		<p>To see how this works, we will step through a few revisions of
		a document by adding and removing content to it.</p>

		<hr>
		<img src="nodeTreeA.png">

		<p>Revision A: We can start with an empty document. This is
		constructed from just a single root node, with no children. We
		indicate this root with a empty square in the diagram above on the
		left hand side of the diagram. The section on the right hand side
		indicates that the A revision of the document has no contents.</p>

		<p>We have coloured this revision of the document gray, and
		labelled it as A. In the forthcoming steps we will assign a new
		colour and ascending letter for each revision in turn.</p>

		<hr>
		<img src="nodeTreeB.png">

		<p>Revision B: We will now add some content to the document, in
		this case the word "One". A new root node is created that is
		associated with the second revision of the document. A leaf node
		is created, which points to the "One" string, and the leaf node is
		then added to the new root as its single child. The document is
		now considered to be at revision two.</p>

		<p>Before continuing, you can see that our diagram still contains
		the first empty root node. In fact at this point we have two
		revisions of the same document. The first is empty, the second
		contains the single "One" word. The contents of each revision is
		indicated at the top right of the diagram, revision A is still
		empty and revision 2 contains the "One".</p>

		<hr>
		<img src="nodeTreeC.png">

		<p>Revision C: We will now add a second word to the document,
		"Two", after the first. A new root node is again created, and a
		Split node is added as its single child this time. A split node is
		an internal node and does not directly reference content, instead
		it has two children; left and right children. An integer split
		value is also kept, and it defines the position of the first
		element of the right child. As we see in the diagram below, the
		round circle indicate a split node, with "One" as its left child,
		and "Two" as its right child. The split value of the node is shown
		to be the value 4. This is the position of T character of the
		right "Two" child. The "O" of "One" has the position 1.</p>

		<p>One of the interesting aspects of the data structure is
		starting to emerge. The third revision C is uses as much of the
		previous revision as possible, so in this case we see that the
		"One" of C's "OneTwo" content is actually shared with the previous
		B region. The printout of the content for each revision at the top
		right of the diagram shows that each revision is keeping the same
		contents, even as further revisions are re-using some of their
		contents.</p>

		<hr>
		<img src="nodeTreeD.png">

		<p>Revision D: We will now add a third element to the end of the
		document, "Three". Again a new root is created, together with a
		split node as its child. The right child of this split is set to
		the new "Three" value and a split value of 7 is stored. More
		interesting is that the left child of the split points to the
		split that we have previously created. We are now sharing content
		and data structures of previous revisions. This hints at possible
		space savings across multiple revisions of the same document.</p>

		<hr>
		<img src="nodeTreeE.png">

		<p>Revision E: We will add a fourth element, "Four", but this time
		rather than appending to the end of the document, we will instead
		insert this new element between "Two" and "Three". A new root node
		and child split node is created. The left node connects into C's
		child. The right child connects to a second split which it in turn
		connects to the "Four" and "Three" contents. If you trace the leaf
		nodes from left to right starting from the E root node you will
			see that the desired document content is collected.</p>

		<hr>
		<img src="nodeTreeF.png">

		<p>Revision F: In this case we will try to remove one of the
		existing elements for our next revision, in this case the word
		"Two". Even though our new revision shouldn't contain "Two", we
		want the previous revisions to still contain it. To implement this
		we define a new root node and child split node. The split node
		then connects to "One" on the left and the parent of "Four" and
		"Three" on the right.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Element Positions</h3>
</td></tr></table>

		<p>One issue that we have only briefly dwelled on is how to use
		the data structure that we have built up. The single case we have
		concentrated on is retrieving the entire contents of a specific
		revision of a document. This is achieved by walking all leafs of a
		tree starting from the left most one.</p>

		<p>Another primitive operation is to retrieve an element at a
		specific position of a document, or a range elements from one
		position to another.</p>

<h4>Example</h4>

		<img src="nodeTreeF.png">

		<p>Looking back at revision B we can see that retrieving the
		element at position 1 is the character "O" (assuming 1-based
		number scheme). This can be found by looking at the single child
		of the B root, and then just a simple #at: request on the contens
		of that leaf node.</p>

		<p>Retrieving the element at specified position is more
		interesting for revision C. Assuming we want to retrieve the
		character at position 5, then we can make use of the split value
		of the Split child of the C root. This includes a value of 4,
		which is the position of the first element that could be found by
		following its right child. So to retrieve the character at
		position 5, we start at the C root, find its child, see that 5 is
		greater or equal to the split value of 4. Follow the right branch,
		and knowing that the first element of the found "Two" content has
		a global position of 4, then we can easily find the the second
		character of its content, "w" is the character at the global
		position of 5.</p>

		<p>Moving onto finding the character at the 5th postion of
		revision D, then we can follow a simple path. Starting at the D
		root, we can see that 5 is less than the split value of 7 for its
		child, which will send us down its left branch. At that point 5
		&gt;= 4 and so we end up at the "Two" leaf node again.</p>

		<p>The more interesting case is with revision F. Again we are
		looking for the character at position 5. Starting at the F root,
		we travel to its single Spit child node, whose split value is 4.
		As 5 &gt;= 4, we follow the right child, and we this time we make
		use of a the +3 displacement value that has been associated with
		the right branch. The displacement value is applied to the
		position 5 that we had been looking for, so that when we arrive at
		the end of the right branch we are now looking for the position 8
		(5 + 3). As 8 &lt; 11, we take the left most branch and retrieve
		the last but two character, "o".</p>

		<p>The displacement that we applied while navigating leafwards has
		enabled the F revision to share the 11 sprit node from the E
		revision. This split node when defined for the E revision had a
		global position of 11, as the F revision has deleted the "Two"
		text before it, that nodes position within the F revision is
		actually 9, but changing the split value of that node would then
		break the E revision. By associating the displacement value with
		the new split node added for the F revision, we are able to share
		this node from E.</p>

		<p>So the neat thing about the displacement idea is that even if
		we insert and delete elements, later revisions can still share
		split nodes from earlier revisions, even if the global positions
		of those nodes now differes across the numerous revision that
		share that node.</p>

<h4>Root-ward walk</h4>

		<p>When walking rootwards, from leaf to root, the inverse of the
		displacement is applied. This enables you to learn the global
		position from any element in a leaf node. Those of you on the ball
		we will now realised that tracing a path up to a root is actually
		now an involved issue, because a leaf could have a number of
		roots. This is not a common problem with tree data structures! We
		will investigate this issue later.</p>

<h4>Demo implementation</h4>

		<p>The Demo implementation stores a separate displacement for both
		the left and right children of a split node. Whenever you follow
		either the left or right branch, the displacement is applied to
		the position that is being found.</p>

<h4>Udanax-Gold implementation</h4>

		<p>The Udanax-Gold Split node implementation has a number of
		differences from the one described above.</p>

		<ul>

				<li>Rather than a simple split value, Gold has a region that
				defines all positions that can be found in its left
				children.</li>

		<li>The displacement value is stored in a separate node of the
		tree called the DspNode, rather than embedded within the split
		node. This gives a lot more flexibility. The author went with the
		simpler technique of embedding the displacement in the Split node,
		and a similar displacement for Root nodes. Somehow this seemed to
		end up with more code than the Gold implementation. At the heart
		of it, it is unknown why Gold went with the separate DspNode, and
		whether it should be copied.</li>

		<li>As Gold supports more than integer positions, the displacement
		value may also be a non-integer.</li>

		</ul>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Version support</h3>
</td></tr></table>

		<p>We ended off the above description of walking the nodes of a
		revision tree, with the issue of walking from a leaf to its root.
		Normally this is a very easy operation in tree data structures,
		assuming suitable parent references. The complexity in this case
		is obvious if you look at the "Three" leaf in the final diagram
		for revision F. The "Three" leaf node actually has two parents,
		one is the 7 split node associated with revision D, and the other
		is the 11 split node associated with revisions E and F. Which of
		the two parents should be followed?</p>

		<p>For the demo each non-leaf node includes a revision number
		associated with the revision for which it was originally created.
		Whenever one walks the tree root-wards, a desired revision is also
		known which can be used to resolve the parent choice. So for
		example, if we want to learn the global position of the first
		character of "Three" for revision F, we want to walk root-ward
		from its leaf node. There are two immediate parents, the 7 or 11
		split nodes. We will take the 11 split node as that node was
		created with revision E, which is closer to revision F than the D
		of the 7 split node. At this point we again have two parent
		choices, and the 4 split node of revision F is obviously the
		preferred route. At that point its single parent is the revision F
		root and so we have reached our destination. Applying inverse
		displacements we can calculate that the T of "Three" is at the
		global position of 8 for revision F.</p>

<h4>Revision Numbers</h4>

		<p>A revision number is not a simple integer, but a branching
		number with a format such as "1:4:1". The first revision is "1",
		the second "2", and so on. If another revision is made from the
		first revision, then that is known as "1:1:1" with the next on that
		branch being "1:1:2".</p>

		<img src="branching-number.png">

		<p>Reviewing the diagram we can see that revision "2" has three
		following revisions, "3", "2:1:1" and "2:2:1". A branch is
		considered the path from the root revision "1" to the specified
		revision. For example "1", "2", "2:1:1", "2:1:2", "2:1:2:1:1" an d
		beyond form a branch.</p>

		<p>We discussed earlier in this section navigating root-wards and
		deciding which one of possibly multiple parents should be
		followed. Given a desired revision we choose the parent whose
		created revision is closest to the revision we are interested in.
		The closest revision has to be on the same branch and then the
		nearest revision before or equal to the desired revision.</p>

<h4>Udanax-Gold implementation</h4>

		<p>There are significant differences between the demo and
		Udanax-Gold in this area.</p>

		<ul>

				<li>Gold supports the concepts of Canopies which enable a
				number of features, one of which is associating a node with
				all the document editions that reference that node.</li>

			<li>The concept of a revision number is not present, and instead
			the ID of the edition itself can be used.</li>

			<li>Canopies also enable faster determination of whether a node
			belongs to a revision or not, which for the demo would require
			walking root-wards a significant distance.</li>

		</ul>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Tree Balancing by Splaying</h3>
</td></tr></table>

		<p>The advantage of a tree as a search data structure is that the
		height of the tree is O(logN), where N is the number of leaves in
		the tree. This feature only holds if a tree is balanced. For
		example in the worst case nodes form a chain from the root with
		children always being to the left. This will form an O(N) tree, or
		effectively a linked list.</p>

		<p>The Ent appears to use the Splay Tree balancing method. This is
		an amortised balancing technique, and so balances a tree across a
		number of operations rather than after a single specific
		operation. This kind of balancing enables the cost of balancing to
		be spread out over all operations, and it can adapt to a changing
		pattern of accessing the tree over time.</p>

<h4>Brief summary of Splay tree algorithm</h4>

		<p>The process proceeds by applying a splaying operation on every
		access to the tree; for example find, inserts and deletes. When
		accessing a tree, the node that is to be effected is first found,
		then the splaying operation will through a series of alternating
		rotate operations pull that node towards the root of the tree.</p>

		<img src="splay-rotate-right.png">

		<img src="splay-rotate-left.png">

		<p>The two basic operations of the algorithm are rotate left and
		rotate right. Both right and left rotations are shown above with
		before and after. X marks the node that is to be rotated, and P is
		the parent of X which X is going to be rotated about. A, B and C
		represents sub-trees of any depth that are children of X and Y.
		The most immediate point of interest is that the X node moves
		root-wards up the tree.</p>

		<p>The algorithm sequences of left and right rotations, depending
		on the path between the focused node and the root of the tree, to
		pull the focused node to the root of the tree or one of its
		immediate children. This pattern of rotations tends to bunch up
		single chains of nodes producing a 'bushier' tree, and assuming
		locality of reference should reduce the access cost for succeeding
		node references.</p>

		<tt>
			<ul>
				<li>If X is the left child of the root, then rotate right
				about Parent.</li>
				<li>If X is the right child of the root, then rotate left
				about Parent.</li>
			  <li>If X and its Parent are both left children, then rotate
				right about Parent followed by a rotate right about X.</li>
			  <li>If X and its Parent are both right children, then rotate
				left about Parent followed by a rotate left about X.</li>
			  <li>If X is a right child and its Parent is a left child, then
				rotate left about Parent follow by a rotate right about original
				Grand parent.</li>
			  <li>If X is a left child and its Parent is a right child, then
				rotate right about Parent follow by a rotate left about original
				Grand parent.</li>
		</ul>
	</tt>

<h4>Algorithm References</h4>

		<p>Please investigate the following references for better
			descriptions of the algorithm, analysis of its performance and
			example implementations.</p>

		<ul>
				<li><a href="http://doi.acm.org/10.1145/3828.3835">Self-adjusting binary trees</a> - Sleator &amp; Tarjan 1985 - Original academic paper on Splay trees</li>
			<li><a href="http://www.cs.mcgill.ca/~rsinge/web251.html">Splay Trees</a> - Ron Singer - Overview of amortized analysis and splay tree operations.</li>
			<li><a href="http://www.hut.fi/~ccandoli/botanica/algorithms/java/SplayTree.java">SplayTree.java</a> - Java implementation of splay trees.</li>
			<li><a href="http://www.cs.caltech.edu/courses/cs134/cs134b/2002/labs/lab1/lab1.pdf">Splay trees - Implementation of a functional splay tree.</a></li>
		</ul>


<h4>Reviewing Displacement Navigation</h4>

		<img src="dsp-navigate.png">

		<p>Before investigating the effects of rotations on displacement,
		a quick walk through the example tree that will be experimented
		on. The three trees shown above are in fact the same tree, and
		show three separate walk throughs, the first finding element at
		position 1, the second position 2 and the third position 3. The
		tree itself contains the string with three characters "XYZ". "X"
		was originally added at position 9, "Y" at 11 and "Z" at 13. The
		version of the document that we are now querying to only contains
		those three characters.</p>

		<p>If we following the centre trace, which shows the process of
		finding the element at position 2. The Yellow line indicates the
		steps followed. Starting with a desire to find the element at
		position 2, we apply the displacement +4, so that we are now
		looking for the element at 6. The 7 split node indicates we should
		follow the left child, where we apply a displacement of +6, so
		that we are now looking for the element at 9. The 9 split node
		indicates we should follow the right child, where we apply a
		displacement of +2, so that we are now looking for the element at
		11. We finally arrive at the leaf and correctly find the "Y"
		element. Additionally you can see that our original query for
		position 2 has been converted through a series of steps to a query
		for position 11, which is the global position at which "Y" would
		have been originally added to in its revision.</p>


<h4>Displacements and Rotations</h4>

		<p>Thinking back to the Demo implementation of Split nodes, and
		you will remember that a displacement is associated with left and
		right children of the node. This feature is not part of standard
		binary search tree and so we have to resolve the impact of
		that.</p>
	
		<img src="dsp-rotate-right.png">

		<img src="dsp-rotate-left.png">

		<p>The above diagram shows the impact of a rotation towards the
		right, and below that a rotation towards the left. The second
		example is actually a continuation of the result of the first, and
		so after a rotate right, followed by a rotate left, we end up with
		the original tree again.</p>

		<p>If you take a closer look at the top pair of trees, the left
		hand tree is the before, and the right hand tree is the result of
		rotating the 9 split node towards the right. You can see in the
		result that the 9 split node is now the parent and the previous 7
		parent is now the child of the 9 node. The three nodes X, Y and Z
		are still in the correct order, but we see that the Y leaf is now
		the child of the 7 split rather than the 9 split. The original
		tree includes a displacement for each arc, and these are labelled
		starting at A for +4 at the top of the tree. In the resultant tree
		the displacements are calculated to ensure that the positions 1, 2
		and 3 will still lead to the characters "X", "Y" and "Z"
		respectively. The calculations are shown using the labelled
		displacements from the first. For example the displacement at the
		top of the tree is now +7 and is the result of adding the A and B
		labelled displacements from the original tree.</p>

<h4>Handling Multiple Parents</h4>

		<p>A second complexity enjoyed by the demo implementation that is
		beyond the trees discussed in the splaying paper, is that a node
		in these trees may have more than one parent. This is a very
		significant difference!</p>

		<img src="dsp-rotate-right-mixed.png">

		<p>We are again going to show a rotate right operation, but this
		time the 9 split node has two parents. One is the root node for
		its revision D. The other parent is the 7 split node of a later
		version.</p>

		<p>Looking closely at the before tree you can see that from the D
		revision root node, position 1 finds "X" and position 2 finds "Y".
		Starting above 7 split node which is from a later revision we can
		see that position 3 finds "X", position 4 finds "Y" and position 5
		finds "Z". Node that X for example has a different position for
		each revision.</p>

		<p>If we look at the result of rotating right about 9 split node
		you will see something interesting. From the start we can see that
		the 9 split node from the D revision is now the parent of the 7
		split node which is actually associated with a later revision than
		itself.</p>

		<p>Tracing down from the D revision root node we still find that
		position 1 finds "X" and position 2 finds "Y". But now we find
		that there is a position 3 would find "Z". We have broken the
		integrity of revision D as it can now includes Z in its content,
		which it didn't before the operation.</p>

		<img src="dsp-rotate-right-duplicate.png">

		<p>The solution the Demo uses for this case would be to duplicate
		the 9 split node before the rotation. This is indicated in the
		diagram above, and you can see that the result preserves the
		integrity of both revisions. Note that the D revision nodes are
		now completely untouched.</p>

		<p>This strategy of duplicating a node if it and another node from
		a different revision are part of a rotation has an obvious
		downside that we are re-using less of an earlier revision than
		before. Over time this strategy would end up duplicating a
		significant proportion of all nodes, and so the demo attempts to
		minimise the number of rotations by not only rotating on inserts
		and deletes rather than finds. This significantly degrades the
		quality of the Splay tree algorithm, and wouldn't be acceptable
		for a non-demo version of the software. The author hasn't analysed
		the situation enough to be able to suggest an alternative strategy
		without this limitation.</p>

<h4>Udanax-Gold implementation</h4>

		<p>Udanax-Gold use of splaying inspired the demo use of it. The
		details of Gold implementation are unknown to the author, but it
		is clearly implemented in a significantly cleaner way using a
		table driven mechanism. The use of canopies and separating
		displacement values into their own nodes feels like it might side
		step the mess that the Demo gets when handling multiple parents. A
		closer analysis to the Gold implementation in action is going to
		be critical in deciding whether splaying has any value in the long
		term as the tree balancing algorithm.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Insert and Delete algorithm</h3>
</td></tr></table>

		<p>The earlier discussions over the use of the tree data structure
		for sharing content between revisions glossed over the mechanisms
		for deciding what nodes need to be created and who they connect
		to.</p>

		<p>The insert and delete algorithms both rely on the splaying
		operation to pull the nearest node root wards to one of a small
		number of known patterns. At that point a predefined set of
		mutations can be applied.</p>

<h4>Insert operation</h4>

<h4>Delete operation</h4>

		<p>TODO: rotating around target node to top to match a small
		number of recognised patterns that could then be modified.</p>

<h4>Udanax-Gold implementation</h4>

		<p>Currently the author does not know how Udanax-Gold approaches
		this problem.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Transclusions</h3>
</td></tr></table>

		<p>Transclusion enables the sharing of content by quoting from the
		original source. Transclusion is a primitive function of the
		implementation, which even hyperlinks are created from.</p>

		<p>Transclusions are implemented under the covers by making use of
		a layer of indirection between the leaves of an Ent tree and the
		actual content. A content element contains a collection of parent
		leaf nodes belonging to possibly different document trees that it
		is a member of. This allows some content to belong to multiple
		documents, or that multiple documents quote the same content.</p>

		<p>Reviewing the Transclusion summary from the first paragraph of
		this section, we see "...by quoting from the original source". In
		fact in the current implementation there is no distinction between
		the document that originally contained a reference to the content
		and subsequent references. A missing feature from Udanax-Gold
		would be storing the owner of the content, which would either by
		the author or the owner/publisher.</p>

		<p>The UI for the Demo specifies a transclusion operation by
		altering the behaviour of the copy-and-paste action. When pasting,
		rather than just inserting a copy of the text that was initially
		copied, instead the original text is quoted.</p>

<h4>ContentLeaf implementation</h4>

		<p>Lets first consider a simple case. A document revision holding
		a single character "X". We can draw another tree diagram as we
		have numerous times above.</p>

		<img src="transclude-single.png">

		<p>The second diagram is peeling back the conceptual skin of the X
		leaf node on the first, to reveal that the leaf node actually
		doesn't hold the "X" character, but in turn references a
		BeDataHolder object holding the "X" character. The value of this
		indirection is that the same "X" character can be included
		(transcluded) other times in the same document revision, other
		revisions or even other documents. In all cases the leaf node
		representing "X" will reference the same BeDataHolder.</p>

		<p>BeDataHolders include a collection of parents, which are all
		the leaf nodes that reference it and so represent its contents.
		This enables you to find all revisions and documents that
		transclude this contents.</p>

		<p>The example has so far considered simple content such as a
		character, but later on we will find that the content leaf can
		reference other types of content elements, such as BeEdition or
		BeWorks which in turn could represent significant quantities of
		content.</p>

<h4>CollectionLeaf implementation</h4>

		<p>The CollectionLeaf is an optimisation for the ContentLeaf.
		Imagine the user adds the phrase "Aaron A Aardvark" in one
		operation. Creating 17 leaf nodes and 17 BeDataHolders each
		holding a single character of the phrase would be a performance
		disaster. CollectionLeaf and its paired BeContentHolder content
		element is an attempt to reduce the overhead. In this case a
		single CollectionLeaf leaf node would be created, that would
		reference a single BeContentHolder that would holder the 17
		characters as a single String object.</p>

		<p>If the same contents was transcluded to a different document, a
		new CollectionLeaf would be created that would be added to its ent
		tree, but it would reference the same BeContentHolder instance and
		so have access to the 17 characters.</p>

		<img src="transclude-multiple.png">

		<p>What if another document simply wanted to transclude the
		"Aardvark" section of the phrase. In that case again a new
		CollectionLeaf would be created that would be added to its ent
		tree, and it would reference the same BeContentHolder, but would
		record that is was only interested in a region of the entire
		contents of the holder, positions 9 to 16 inclusive.</p>

<h4>Udanax-Gold implementation</h4>

		<p>The Udanax-Gold equivalents for the ContentLeaf and
		CollectionLeaf classes and the content element classes that they
		reference are somewhat of a mystery to the author at the
		moment.</p>

<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>EntNode class hierarchy</h3>
</td></tr></table>

		<p>The class hierarchy for the tree nodes is strongly inspired by
			the Udanax-Gold implementation but includes some
			simplifications, especially for the Leaf classes as a result of
			a lack of knowledge on my part for how this group of classes
			relates to the content classes.</p>

		<ul>
			<li><b>EntNode</b> - Abstract super-class of all 
				nodes that are present in an Ent tree.<br>&nbsp;&nbsp;branch - revision number of edition that
				created this node</li>
			<ul>
			<li><b>ChildNode</b> - Abstract super-class for all nodes that can be
			children of others.<br>&nbsp;&nbsp;parents - list of parent EntNodes</li>
			<ul>
			<li><b>LeafNode</b> - Abstract super-class for all nodes that
				can be leafs of the tree. These nodes holds the contents of
				the tree with 0 or more elements.<br>&nbsp;&nbsp;startPosition
			- Global position of revision this node was originally created in.</li>
			<ul>
			<li><b>CollectionLeaf</b> - Leaf node that references a subset
				of the element of a BeCollectionHolder.<br>&nbsp;&nbsp;collectionHolder - BeCollectionHolder
			that actually contains the elements that this leaf node
				represents.<br>&nbsp;&nbsp;collectionRegion - which of the
				collectionHolders elements does this node represent. This is a
			simple region defining the first and last index considered part
				of the region.</li>
			<li><b>ContentLeaf</b> - Leaf node that references a
				BeContentElement considered as a single
				element. This could be a BeDataHolder holding a single
				Character or something more interesting such as a BeEdition.<br>&nbsp;&nbsp;contentElement - BeContentElement holding
				the single element that the leaf represents. </li>
		  </ul>
		  </li>
      <li><b>SplitNode</b> - Internal node of the tree that has two
			children known as left and right.<br>&nbsp;&nbsp;split - integer
		split value which is the position of the first element available
			from its right child.<br>&nbsp;&nbsp;left - ChildNode child
			considered its left child.<br>&nbsp;&nbsp;leftDsp - integer
			displacement value applied to the current position when
			traversing to the left child.<br>&nbsp;&nbsp;right - ChildNode child
			considered its right child.<br>&nbsp;&nbsp;rightDsp - integer
			displacement value applied to the current position when
			traversing to the right child.</li>
		  </ul>
		  <li><b>RootNode</b> - Internal node at the top of the tree that
			holds a single child. Roots are considered if the child has not
			been set yet. BeEditions hold a reference to a single RootNode
			which is considered the root of the contents it
			represents.<br>&nbsp;&nbsp;edition - back link to the BeEdition
			that root holds contents for (Cant remember if this is here only
			for debug purposes...).<br>&nbsp;&nbsp;child -
			single ChildNode of the root, may be null.<br>&nbsp;&nbsp;dsp - integer displacement value
			applied to the current position when traversing to the child.</li>
		  </ul>
		</li>
		</ul>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>BeContentElement class hierarchy</h3>
</td></tr></table>

		<p>The BeContentElement class hierarchy is a subset of the content
			classes supported by Udanax-Gold. An instances of this class
			specify the content of documents.</p>

		<ul>
			<li><b>BeContentElement</b> - Abstract super class of content
				elements.<br>&nbsp;&nbsp;parents - un-ordered collection of
				ent leaf nodes that represent this element as their content.</li>
			<ul>
			<li><b>BeCollectionHolder</b> - Holder of multiple elements,
				each of which is a primitive data
				element.<br>&nbsp;&nbsp;collection - ordered collection of
				primitive data elements</li>
			<li><b>BeDataHolder</b> - Holder of a single primitive data
				element.<br>&nbsp;&nbsp;value - primitive data element.</li>
			<li><b>BeEdition</b> - Represents the contents of a single
				edition of a work. References a single RootNode which is the
				root of the ent tree that holds its actual
				contents.<br>&nbsp;&nbsp;root - the RootNode that holds the
				edition contents.<br>&nbsp;&nbsp;branch - the revision number
				used to tag its own tree nodes.<br>&nbsp;&nbsp;works - BeWorks
			that have this edition as their contents.<br>&nbsp;&nbsp;...more...</li>
			<li><b>BeWork</b> - identity of a document, and also the point
				of access control to the content.<br>&nbsp;&nbsp;edition -
				single BeEdition that holds the works content.<br>&nbsp;&nbsp;...more...</li>
			<ul>
			<li><b>BeClub</b> - work that defines the members of group with
				access to a work.</li>
			</ul>
		</li>
		</ul>
		</li>
		</ul>

<h4>Udanax-Gold implementation</h4>

		<p>The demo implementation is closely modelled after that of
			Udanax-Gold.</p>

		<ul>
				<li>Udanax-Gold uses the term BeRangeElements rather than
			BeContentElements. Content seems a little better
				description.</li>
			<li>Missing BePlaceholder class. The implementation of the Demo
				simply hasn't progressed far enough to make use of this. A
				place holder is very interesting idea and is a critical
				enabler of some of the interesting features of Gold. It acts
				as a stand in for a future content element that currently
				isn't available yet. For example the actual element hasn't
				been returned yet as the result of a search, or may not even
				exist yet for long running searches.</li>
		</ul>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Extra Ent Udanax-Gold features</h3>
</td></tr></table>

		<p>The Demo implementation is focused on a simple domain of
		contiguous integers starting from 1. The UG implementation extends
		the supported domain into a far more generalised coordinate-space
		system. The demo split-integer is instead a generic region of
		inclusive positions.</p>

		<p>The Demo includes no separation between the document node tree
		and revision identity of those nodes. The nodes includes a
		revision number that indicates when that node was created. The up
		side of this is the simplicity and directness of the
		implementation. The down side is highlighted by the alternative
		path that UG took. The UG document nodes do not contain a revision
		identity, instead there is a concept of canopies that associates
		nodes within revisions. Additionally there does not appear to be
		the concept of a revision number, which has a problem with
		distributed generation, and instead seems to be based on the
		uniqueness of IDs associated with works together with works
		holding a list of previous revisions (? this might be a level
		apart and so not relevant to this ?).</p>

		<p>The Demo probably has problems with Garbage Collection, and
		loosing references to document revisions and editions that are not
		being used. This is apparently handled by UG.</p>

		<p>UG Ent has a different set of set of leave nodes that connect
		to content. The Demo does not follow the actual UG implementation
		due to a lack of understanding of its semantics and constraints on
		it.</p>

		<p>TODO: Placeholders</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>API Level Objects</h3>
</td></tr></table>

		<p>TODO: Move this to a better place</p>

		<p>Attention needs to be drawn to the visibility of objects and
			structures in the system from the point of view of a consumer of
			the programming API. The programmer of a front-end application
			that uses the demo API talks in terms of content elements,
			endorsements and objects of that ilk. Under the covers that are
			entirely oblivious to the Ent data structure and things such as
			ContentLeafs.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Works</h3>
</td></tr></table>

		<p>Works define the identity for a document, and its edition
		provides its contents.</p>

<h4>Revising a work</h4>

		<p>A work holds a single edition which is considered the current
		content of that works revision. As editions are read-only, any
		attempt to modify the contents of the edition results in a new
		edition that incorporates the existing content and the desired
		change. A work must then be <b>revised</b> to reference the
		updated edition.</p>

		<p>Revising a work to a new edition requires one to have
		previously gained a <b>lock</b> to the work. This gives one the
		exclusive rights to revise the work as many times as one likes
		while the lock is held. The unlock operation gives up the revise
		right for others to take. A unlock automatically occurs when
		either the front-ends reference to the work is lost, or the
		connection from the front-end to the server on which the work is
		stored is lost.</p>

		<p>This limitation of a single work modifier at a time on the face
		of it seems to be a little restrictive. For example a user could
		lock a Work for the majority of the day, restricting any other
		user of the system from modifying it during that time. This
		problem is side stepped in a very interesting way. A work is
		simply the identity for a document, with its content held by its
		associated edition. Any number of works may reference the same
		edition, so this allows a second writer to create a new temporary
		work on the original edition of the first work which they can then
		edit freely. Once the lock on the original work is released, they
		can then gain the lock and merge in any changes from their edition
		as need be.</p>

<h4>Histories and frozen works</h4>

		<p>A work can be frozen which toggles it into a permantent
		read-only state. Once frozen it will not allow itself to be
		revised to hold a different edition as its contents. As editions
		are effectively immutable, that safeguards the works content from
		changing. Even in a frozen state, the works list of endorsement
		can still be modified.</p>

		<p>A work can store a list of previous revisions of itself. These
		are frozen works so their content can not be changed. The history
		is extended each time the work is revised. The current time is
		associated with the frozen work.</p>

<h4>Identity</h4>

		<p>The work holds an ID object which uniquely identifies the work
			on this machine.</p>

<h4>Udanax-Gold implementation</h4>

		<ul>

			<li>Access to the features of a work is restricted by the use of
			clubs; read, edit and history clubs. There is a BeClub class in
			the demo, but it currently is not actively tied into any
			authorisation system.</li>

			<li>By default Works do not build up a history of previous
			frozen works, and this must be explicitly enabled. The author
			assumes that recording histories is off by default to reduce the
			space overhead.</li>

			<li>Freezing of Works is accomplished in Gold by deleting the
			works edit club, so removing the authority to make changes from
			any authority. The demo does not support the concept of clubs
			yet, and so a direct <code>isFrozen</code> flag is used.</li>

			<li>In Udanax-Gold a front-end can request to be notified when a
			work is revised. As the support for front-ends is not complete
			yet in the demo, this feature is not in place.</li>

			<li>The demo only allows a simple list of frozen works making up
			the history of a work. It is not known at this point if
			Udanax-Gold allows a tree of revisions of the work to be built
			up. On the face of it, this would only be possible if you could
			thaw out an existing frozen work which doesn't seem right.</li>

		</ul>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Editions</h3>
</td></tr></table>

		<p>An edition forms effectively an immutable object, and
		modifications to its contents will result in a new edition
		containing the original contents and the modifications.</p>

		<p>The contents that an edition holds can be both collections of
		simple data elements such as characters, or it can form a
		composite structure holding further editions and works.</p>

<h4>Revision Number</h4>

		<p>The edition holds a revision number for itself, and is able to
			respond with the next valid revision number after itself. It
			records the highest revision number it has given out so that it
			can properly generate subsequent revision numbers.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Differences</h3>
</td></tr></table>

		<p>Given two documents, what are the similarities and the
		differences between them? This is a feature supported by word
		processors, text editors and custom differencing tools such as the
		unix <i>diff</i> tool. Most of these implementations start with two
		arbitrary text and can calculate a set of differences from them.
		The quality of the results varies tremendously based on the input
		texts, uniqueness of terms, quantity of repetition, and the number
		of differences. Results may be at the granularity of individual
		lines or even down to words or characters within a line. The
		resulting differences are usually broken down into primitive
		insert, delete and modification differences. So if a block of text
		is moved from the start of a document to the end, this will be
		recorded as a delete from the first document, and an insert into
		the second. This simplification unfortunately distances the
		results from the user level actions that originated these changes,
		which the user would obviously prefer to see as their changes.
		Differencing tools can often support an extended form of this
		involving three files, with one considered the elder version of
		the second and third files.</p>

		<p>The demo implementation is completely different from the
		standard techniques highlighted above. The high level spin on this
		is that the demo finds the similarities between two documents,
		rather than the differences. The demo can accurately indicate
		moved and copied blocks of text in addition to the simple insert,
		delete and modification differences one usually finds. It also
		wont get confused by some of the issues that degradate the results
		from the classic differencing tools.</p>

		<p>The downside of the demo implementation is from its inherent
		implementation. It works by finding what content is shared by the
		two documents that are being compared. So given a simple text
		edition. If that content is transcluded by another edition, then
		those editions will be seen as being the same - because that
		actually reference the same content elements. But if one was to
		retype in the contents of the first edition in a new edition, so
		it appears to be exactly the same, then those two editions would
		be seen as completely different. Even though each element of the
		two has the same character value, they aren't the same character
		element, so they are different. So even though the tool can
		provide superior results to the standard differencing techniques,
		it is useless for texts entered without reference to each
		other.</p>

		<p>To help with the problem of parallel entered texts, it would be
		possible to pass this through a standard differencing tool, though
		it would probably lead to even more confusion.</p>

<h4>API</h4>

		<p>As mentioned the implementation works by walking through two
		editions and building a map between each of the content elements
		that they share. It can handle a content element being including
		in a different location between the two, or an element being
		included more than once.</p>

		<p>The user level API for an edition is the
		<code>BeEdition>>sharedWith: anotherEdition</code> method which
		returns an ordered collection of mappings. The mapping is simply a
		mapping from a range of elements of the first edition to another
		range of elements in the second. There could be multiple mappings
		for the same element if the same content occurs more than
		once.</p>

<h4>UI rendering of results</h4>

		<p>Once returned to the UI, the steps required to show this to the
		user by painting is relatively simple.</p>

		<p>For the case of painting a different background colour, it's
		just a case of walking the mappings and a sequence of alternative
		colours, and just painting them.</p>

		<P>TODO: show example</p>

		<p>The thin vertical mapping window that draws a connections
		between the individual characters of the two editions has an
		interesting issue in that the connections do overlap, so it's not
		possible to ensure that useful connections are not obscured. The
		simple strategy the author took was to paint the largest mappings
		first, and then overlay the smaller mappings on top of that.</p>

<h4>Implementation</h4>

		<p>Each of the leafs of the source edition are walked one by one.
		For each leaf, the content element that they represent is fetched,
		and in turn all of the leafs which represent it. These other leafs
		are then walked, and any which aren't members of anotherEditon and
		its revisionNumber are ignored. Of the remaining leafs, their
		global positions are calculated and a mapping between the global
		position of the source leaf to the global position of the each of
		these leafs is collected.</p>

		<p>In the case of CollectionLeafs there is also an additional test
		to make sure that there are some elements of the content element
		shared between the subsets of that content held between the two
		leafs. If there is a match, then the range of common elements
		between the two is calculated and a suitable mapping created.</p>

		<p>TODO: diagram showing the combining of mappings</p>

		<p>Once all the mappings have been collected for the leafs of the
		edition tree, then a further processing step is employed to
		convert the mappings into a more coherent and convenient result
		for use by clients. Mappings are sorted by their global positions,
		and contiguous mappings are combined over their combined range.
		The actual algorithm used is potential expensive, and involves
		multiple passes over the mappings until no improvement in a
		processing round can be found.</p>

<h4>Udanax-Gold implementation</h4>

		<p>The requirements for the demo differences were gathered from a
		few comments around the Udanax-Gold behaviour. The implementation
		was done from scratch so could well miss out on some critical
		features and performance ideas from the original.</p>

		<p>One aspect of the Udanax-Gold implementation is its apparent
		ability to work on documents from any coordinate-space. This is
		one area where standard differencing tools are very weak, and can
		only be constructively applied to text. The author assumes that
		given a two-dimensional image of a face, if a second edition of
		the image was created by painting the eyes green, that a
		differencing operation between these images would properly
		highlight that the pixels making up the eyes have changed. This
		might be particularly interesting with collages.</p>

		<p>The performance of the demo is hampered by the need to walk
		root-ward up ent trees from the leafs to find if a content element
		is present for a specific edition and revision. Udanax-Gold
		incorporates some significant performance optimisations in this
		area courtesy of the Canopy systems.</p>

		<p>On a minor note, the Udanax-Gold <code>sharedWith</code> method
		returns an edition rather than the primitive collection used in
		the demo.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Endorsements</h3>
</td></tr></table>

		<p>An endorsement is a tag composed of a club and ID that can be
		associated with an edition on club. It is the primitive means to
		filter out the results at the application level. Endorsements can
		be used to define the type of content.</p>

<h4>API</h4>

		<p>Endorsements are introduced to an edition or club with the
		<code>endorse:</code> message, and removed with the
		<code>revoke:</code> message. The collection of endorsements
		associated with the content acts as Set, so duplicates are not
		kept. The Endorsement class is a simple information holder holding
		a pair of IDs.</p>

		<p>TODO: transclusionsFilteredBy </p>

		<p>TODO: Recording revokes, signing endorsements</p>

<h4>Udanax-Gold implementation</h4>

		<p>There does not appear to be an Endorsement class in
		Udanax-Gold, so a Pair of IDs is probably used.</p>

		<p>The demo supports very simple filtering of results based on a
		flat and operation for a collection of endorsements. Udanax-Gold
		includes a far more flexible filtering mechanism, built from the
		standard coordinate-space with support for standard boolean
		operations together with union and intersection operations.</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Hyperlinks</h3>
</td></tr></table>

		<p>Considering the Demo is classified as a hypertext system, it
		has taken us a long time to reach a description of the
		implementation of the hyperlink that one would assume was a
		primitive operation of the software. In fact hyperlinks are
		implemented using transclusions. I find this particularly
		interesting.</p>

		<p>TODO: show implementation</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Document structures</h3>
</td></tr></table>

		<p>TODO: show how a Work and editions plus links could all fit
			together to from a rich document</p>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Network</h3>
</td></tr></table>


<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>Client Caching</h3>
</td></tr></table>



<table bgcolor="antiquewhite" width="100%"><tr><td>
<h3>References</h3>
</td></tr></table>

		<p>The authors knowledge of the Ent data structure derives from
		two papers plus repeated fumbling readings of the published
		Udanax-Gold source code. The papers I found to be most helpful can
		be found at the Sunless-Sea website.<p>

		<ul>
			<li>@link:xia@</li>
			<li>@link:ent_theory@</li>
		</ul>

<!-- abora:footer -->
$Id$
<!-- abora:footer_close -->
    </body>
  </html>
